html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
bike_json_tbl
get_bike_data <- function(url) {
html_bike_category <- read_html(bike_category_url)
# Get the URLs for each bike
bike_url_tbl  <- html_bike_category %>%
# Get the a nodes, which are hierarchally underneath a div tag and div tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the ?)
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
# Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%
# Get the nodes in the meta tag where the attribute itemprop equals description
html_nodes(css = '.productTile__productSummaryLeft > meta[itemprop="description"]') %>%
# Extract the content of the attribute content
html_attr("content") %>%
# Convert vector to tibble
enframe(name = "position", value = "description")
# Get even more data from JSON files
bike_json_tbl     <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
}
get_bike_data <- function(url) {
html_bike_category <- read_html(url)
# Get the URLs for each bike
bike_url_tbl  <- html_bike_category %>%
# Get the a nodes, which are hierarchally underneath a div tag and div tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the ?)
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
# Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%
# Get the nodes in the meta tag where the attribute itemprop equals description
html_nodes(css = '.productTile__productSummaryLeft > meta[itemprop="description"]') %>%
# Extract the content of the attribute content
html_attr("content") %>%
# Convert vector to tibble
enframe(name = "position", value = "description")
# Get even more data from JSON files
bike_json_tbl     <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
}
bike_category_url <- bike_category_tbl$url[1]
get_bike_data(url = bike_category_url)
test <- get_bike_data(url = bike_category_url)
test
rstudioapi::getSourceEditorContext()$path
setwd("~/startupengineer/")
blogdown::serve_site()
asdasdfas
asdasdfas
<!-- HEADING (challenge) -->
## <i class="fas fa-laptop-code"></i> Challenge
library(tidyverse) # Main Package - Loads dplyr, purrr
library(rvest)     # HTML Hacking & Web Scraping
library(xopen)     # Quickly opening URLs
# 2.1 Web SCRAPE BIKE PRODUCT FAMILIY DATA IDs ----
url_home          <- "https://www.canyon.com/en-de"
xopen(url_home)
# Read in the HTML for the entire webpage
html_home         <- read_html(url_home)
# Web scrape the ids for the families
# This step could manually be faster
bike_family_tbl <- html_home %>%
# Get the nodes for the second column (families) (by class (.)) ...
html_nodes(css = ".js-navigationDrawer__list--secondary") %>%
# ...and extract the infromation of the id attribute
html_attr('id') %>%
# Remove the product families Gear and Outlet and Woman (because the female bikes are also listed with the others)
discard(.p = ~stringr::str_detect(.x,"WMN|WOMEN|GEAR|OUTLET")) %>%
# Convert vector to tibble
enframe(name = "position", value = "family_class") %>%
# Add a hashtag in front so that we can get nodes of the product categories by id (#)
mutate(
family_id = str_glue("#{family_class}")
)
bike_family_tbl
# Combine all Ids so that we will get all nodes at once (seperated by the OR operator ",")
family_id_css <- bike_family_tbl %>%
.[["family_id"]] %>%
glue_collapse(", ")
library(glue)      # Combine strings
# Combine all Ids so that we will get all nodes at once (seperated by the OR operator ",")
family_id_css <- bike_family_tbl %>%
.[["family_id"]] %>%
glue_collapse(", ")
family_id_css
# Extract the urls of the entries from the href attribute
bike_category_tbl <- html_home %>%
html_nodes(css = family_id_css) %>%
html_nodes(css = ".navigationListSecondary__listItem .js-ridestyles") %>%
html_attr('href') %>%
# Convert vector to tibble
enframe(name = "position", value = "subdirectory") %>%
# Add the domain, because we will get only the subdirectories
mutate(
url = str_glue("https://www.canyon.com{subdirectory}")
) %>%
# Some categories are listed multiple times. We only need unique values.
# With .keep_all = T we could keep the other columns. But we don't need them.
distinct(url)
bike_category_tbl
# 3.1 Examine Product Family Page ----
# select first bike url
bike_category_url <- bike_category_tbl$url[1]
bike_category_url
xopen(bike_category_url)
# Get the URLs for each bike
html_bike_category  <- read_html(bike_category_url)
bike_url_tbl        <- html_bike_category %>%
# Get the a nodes, which are hierarchally underneath a div tag and div tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the ?)
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
bike_url_tbl
bike_url_tbl        <- html_bike_category %>%
# Get the 'a' nodes, which are hierarchally underneath a 'div' tag and 'div' tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the '?')
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
# Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%
# Get the nodes in the meta tag where the attribute itemprop equals description
html_nodes(css = '.productTile__productSummaryLeft > meta[itemprop="description"]') %>%
# Extract the content of the attribute content
html_attr("content") %>%
# Convert vector to tibble
enframe(name = "position", value = "description")
bike_desc_tbl
# Get even more data from JSON files
bike_json_tbl  <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
library(jsonlite)  # converts JSON files to R objects
# Get even more data from JSON files
bike_json_tbl  <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
bike_json_tbl
get_bike_data <- function(url) {
html_bike_category <- read_html(url)
# Get the URLs for each bike
bike_url_tbl  <- html_bike_category %>%
# Get the a nodes, which are hierarchally underneath a div tag and div tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the ?)
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
# Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%
# Get the nodes in the meta tag where the attribute itemprop equals description
html_nodes(css = '.productTile__productSummaryLeft > meta[itemprop="description"]') %>%
# Extract the content of the attribute content
html_attr("content") %>%
# Convert vector to tibble
enframe(name = "position", value = "description")
# Get even more data from JSON files
bike_json_tbl <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
}
bike_category_url <- bike_category_tbl$url[1]
bike_date_tbl     <- get_bike_data(url = bike_category_url)
bike_data_tbl     <- get_bike_data(url = bike_category_url)
bike_data_tbl
bike_category_tbl
bike_data_tbl
library(purrr)
plan("multiprocess")
library(furrr)
plan("multiprocess")
bike_category_url
bike_category_tbl
bike_category_tbl %>% map(url[1:2], get_product_data)
bike_category_tbl %>% map(url, get_product_data)
bike_category_tbl %>% map(url, get_bike_data)
bike_category_tbl
get_bike_data <- function(url) {
html_bike_category <- read_html(url)
# Get the URLs for each bike
bike_url_tbl  <- html_bike_category %>%
# Get the a nodes, which are hierarchally underneath a div tag and div tag with the class productTile__...
html_nodes(css = "div.productTile__contentContainer > div > a") %>%
html_attr("href") %>%
# Remove the query parameters of the URL (everything after the ?)
str_remove(pattern = "\\?.*") %>%
# Convert vector to tibble
enframe(name = "position", value = "url")
# Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%
# Get the nodes in the meta tag where the attribute itemprop equals description
html_nodes(css = '.productTile__productSummaryLeft > meta[itemprop="description"]') %>%
# Extract the content of the attribute content
html_attr("content") %>%
# Convert vector to tibble
enframe(name = "position", value = "description")
# Get even more data from JSON files
bike_json_tbl <- html_bike_category %>%
html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
html_attr("data-gtm-impression") %>%
# Convert the JSON format to dataframe
# map runs that function on each element of the list
map(fromJSON) %>% # need JSON ### need lists
# Extract relevant information of the nested list
map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above
# Set "not defined" and emtpy fields to NA (will be easier to work with)
map(na_if, "not defined") %>%
map(na_if, "") %>%
# The class of the column dimension56 is sometimes numeric and sometimes char.
# This converts this column in each list to numeric
map(~mutate_at(.,"dimension56", as.numeric)) %>%
# Stack all lists together
bind_rows() %>%
# Convert to tibble so that we have the same data format
as_tibble() %>%
# Add consecutive numbers so that we can bind all data together
# You could have also just use bind_cols()
rowid_to_column(var='position') %>%
left_join(bike_desc_tbl) %>%
left_join(bike_url_tbl)
}
bike_category_tbl
bike_category_tbl %>% map(url, get_bike_data)
bike_category_url <- bike_category_tbl$url[1]
bike_data_tbl     <- get_bike_data(url = bike_category_url)
bike_data_tbl
bike_category_tbl %>% map(url, get_bike_data)
bike_category_tbl
bike_category_tbl %>% map(.url, get_bike_data)
bike_category_tbl %>% map(url, get_bike_data)
bike_category_tbl %>% map(url, print)
bike_category_tbl %>% purrr::map(url, print)
bike_category_tbl %>%
purrr::map(bike_category_tbl$url, print)
bike_category_tbl$url
bike_category_tbl
bike_category_tbl %>%
purrr::map(bike_category_tbl$url, print)
bike_category_tbl %>% map(url, print)
bike_category_tbl %>%
purrr::map(url, print)
bike_category_tbl$url
class(bike_category_tbl$url)
as.list(bike_category_tbl$url)
bike_category_tbl %>% map(as.list(.$url), print)
bike_category_tbl
bike_category_tbl %>% lapply(as.list(.$url), print)
bike_category_tbl %>% lapply(as.list(url), print)
bike_category_tbl %>% lapply(url, print)
bike_category_tbl
bike_category_tbl %>% print(urk)
bike_category_tbl %>% print(url)
bike_category_tbl %>% print()
bike_category_tbl %>% map(print)
bike_category_tbl %>% map(url, print)
bike_category_tbl %>% map(.url, print)
bike_category_tbl
names(bike_category_tbl)
class(bike_category_tbl$url)
bike_category_tbl$url <- as.character(bike_category_tbl$url)
class(bike_category_tbl$url)
bike_category_tbl %>% map(.url, print)
bike_category_tbl %>% map(url, print)
bike_category_tbl %>% map(.$url, print)
bike_category_tbl$url <- as.list(bike_category_tbl$url)
class(bike_category_tbl$url)
bike_category_tbl %>% map(.$url, print)
bike_category_tbl
bike_category_tbl %>% map(.$url, print)
bike_data_cleaned_tbl <- readRDS("~/Desktop/canyon_analysis/bike_data_cleaned_tbl.rds")
bike_data_cleaned_tbl
add_column(color_variations <- NA_character_
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>%
add_column(color_variations <- NA_character_)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>%
add_column(color_variations = NA_character_)
bike_data_cleaned_tbl <- readRDS("~/Desktop/canyon_analysis/bike_data_cleaned_tbl.rds")
bike_data_cleaned_tbl
bike_data_cleaned_tbl %>% glimpse()
bike_data_tbl <- readRDS("~/Desktop/canyon_analysis/bike_data_tbl.rds")
# Filter non Canyon bikes (based on id length)
bike_data_cleaned_tbl <- bike_data_tbl %>%
filter(nchar(.$id) == 4)
bike_data_cleaned_tbl
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>%
add_column(color_variations = NA_character_)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>%
add_column(color_variations = NA_character_) %>% glimpse()
bike_url <- bike_data_cleaned_tbl$url[1]
html_bike                         <- read_html(bike_url)
html_bike %>%
# Get all 'script nodes' and convert to char
html_nodes(css = "script") %>%
as.character() %>%
# Select the node, that contains 'window.deptsfra' and remove the chars that do not belong to the json
str_subset(pattern = "window.deptsfra") %>%
gsub("^[^\\{]+", "", .) %>%
gsub("[^\\}]+$", "", .) %>%
# Convert from json to an r object and pick the relevant values
fromJSON() %>%
purrr::pluck("productDetail", "variationAttributes", "values", 1, "value") %>%
paste0(collapse = ";")
html_bike %>%
# Get all 'script nodes' and convert to char
html_nodes(css = "script") %>%
as.character() %>%
# Select the node, that contains 'window.deptsfra' and remove the chars that do not belong to the json
str_subset(pattern = "window.deptsfra") %>%
gsub("^[^\\{]+", "", .) %>%
gsub("[^\\}]+$", "", .) %>%
# Convert from json to an r object and pick the relevant values
fromJSON() %>%
purrr::pluck("productDetail", "variationAttributes", "values", 1, "value")
bike_url <- bike_data_cleaned_tbl$url[2]
html_bike                         <- read_html(bike_url)
html_bike %>%
# Get all 'script nodes' and convert to char
html_nodes(css = "script") %>%
as.character() %>%
# Select the node, that contains 'window.deptsfra' and remove the chars that do not belong to the json
str_subset(pattern = "window.deptsfra") %>%
gsub("^[^\\{]+", "", .) %>%
gsub("[^\\}]+$", "", .) %>%
# Convert from json to an r object and pick the relevant values
fromJSON() %>%
purrr::pluck("productDetail", "variationAttributes", "values", 1, "value") %>%
paste0(collapse = ";")
html_bike %>%
# Get all 'script nodes' and convert to char
html_nodes(css = "script") %>%
as.character() %>%
# Select the node, that contains 'window.deptsfra' and remove the chars that do not belong to the json
str_subset(pattern = "window.deptsfra") %>%
gsub("^[^\\{]+", "", .) %>%
gsub("[^\\}]+$", "", .) %>%
# Convert from json to an r object and pick the relevant values
fromJSON() %>%
purrr::pluck("productDetail", "variationAttributes", "values", 1, "value") %>%
glue_collapse(", ")
html_bike %>%
# Get all 'script nodes' and convert to char
html_nodes(css = "script") %>%
as.character() %>%
# Select the node, that contains 'window.deptsfra' and remove the chars that do not belong to the json
str_subset(pattern = "window.deptsfra") %>%
gsub("^[^\\{]+", "", .) %>%
gsub("[^\\}]+$", "", .) %>%
# Convert from json to an r object and pick the relevant values
fromJSON() %>%
purrr::pluck("productDetail", "variationAttributes", "values", 1, "value") %>%
glue_collapse(";")
map(1:5, print)
map(c(1:5), print)
map(list(1:5), print)
lapply(list(1:5), print)
bike_category_tbl
bike_data_cleaned_tbl
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% .$url
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% map(.$url, print)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% pull(url)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% map(pull(url), url)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% purrr:map(pull(url), url)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% purrr::map(pull(url), url)
#  4.0 Get all color variations for each bike
bike_data_cleaned_tbl %>% purrr::map(pull(.$url), url)
bike_data_cleaned_tbl %>% purrr::map(url, print)
